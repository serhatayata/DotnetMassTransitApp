//////// PRODUCERS

An application or service can produce messages using two different methods. A message can be sent or a message can be published. 
The behavior of each method is very different, but it's easy to understand by looking at the type of messages involved with 
each particular method.

When a message is sent, it is delivered to a specific endpoint using a DestinationAddress. When a message is published, 
it is not sent to a specific endpoint, but is instead broadcasted to any consumers which have subscribed to the message type. 
For these two separate behavior, we describe messages sent as commands, and messages published as events.

To send a message, the DestinationAddress is used to deliver the message to an endpoint — such as a queue. One of the Send 
method overloads on the ISendEndpoint interface is called, which will then send the message to the transport. An ISendEndpoint 
is obtained from one of the following objects:

- The ConsumeContext, of the message being consumed This ensures that the correlation headers, message headers, and trace 
information is propagated to the sent message.

- An ISendEndpointProvider, instance This may be passed as an argument, but is typically specified on the constructor of an object 
that is resolved using a dependency injection container.

- The IBus, The last resort, and should only be used for messages that are being sent by an initiator — a process that is 
initiating a business process.

Once the Send method has been called (only once or repeatedly to send a series of messages), the ISendEndpoint reference should 
fall out of scope. Applications should not store the ISendEndpoint reference, it is automatically cached by MassTransit and discarded when it is no longer needed.

For instance, an IBus instance is a send endpoint provider, but it should never be used by a consumer to obtain an 
ISendEndpoint. ConsumeContext can also provide send endpoints, and should be used since it is closer to the consumer.

This cannot be stressed enough -- always obtain an ISendEndpoint from the closest scope. There is extensive logic to tie 
message flows together using conversation, correlation, and initiator identifiers. By skipping a level and going outside the 
closest scope, that critical information will be lost which prevents the useful trace identifiers from being propagated.

//////// Send Endpoint

To obtain a send endpoint from a send endpoint provider, call the GetSendEndpoint. The method is async, 
so be sure to await the result.

There are many overloads for the Send method. Because MassTransit is built around filters and pipes, pipes are used to 
customize the message delivery behavior of Send. There are also some useful overloads (via extension methods) to make 
sending easier and less noisy due to the pipe construction, etc.

//////// Send with Timeout

If there is a connectivity issue between the application and the broker, the Send method will internally retry until 
the connection is restored blocking the returned Task until the send operation completes. The Send methods support 
passing a CancellationToken that can be used to cancel the operation.



//////// Endpoint Address

An endpoint address is a fully-qualified URI which may include transport-specific details. For example, an endpoint on a 
local RabbitMQ server would be: rabbitmq://localhost/input-queue

Transport-specific details may include query parameters, such as: rabbitmq://localhost/input-queue?durable=false


//////// Short Addresses

Starting with MassTransit v6, short addresses are supported. For instance, to obtain a send endpoint for a queue on 
RabbitMQ, the caller would only have to specify: GetSendEndpoint(new Uri("queue:input-queue"))

This would return a send endpoint for the input-queue exchange, which would be bound to the input-queue queue. Both the 
exchange and the queue would be created if either did not exist. This short syntax eliminates the need to know the scheme, 
host, port, and virtual host of the broker, only the queue and/or exchange details are required.


